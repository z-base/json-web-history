<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>JSON Web History (JWH)</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        specStatus: 'unofficial',
        edDraftURI: 'https://z-base.github.io/json-web-history/',
        editors: [
          { name: 'Jori Lehtinen', url: 'https://github.com/jortsupetterson' },
        ],
        github: 'z-base/json-web-history',
        shortName: 'jwh',
        xref: ['web-platform'],
        lint: {
          'informative-dfn': true,
          'local-refs-exist': true,
          'no-unused-dfns': true,
        },
      }
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document defines a JSON Web Signature (JWS) profile and abstract
        operations for representing, extending, validating, and merging a
        directed linear history of signed JSON entries. A valid history is
        anchored by a root public key and MAY rotate its verification key over
        time.
      </p>
    </section>

    <section id="sotd">
      <p>
        This document is an unofficial, AI-assisted draft. It is not a
        standards-track publication and MAY change, contain errors, or be
        withdrawn at any time. It is published for implementation
        experimentation and review feedback.
      </p>
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        A history consumer often needs to verify what an issuer intended at a
        particular time, even when snapshots are exchanged across distributed
        systems. This document specifies a JOSE-based format and deterministic
        operations that preserve a single verified linear chain anchored at a
        root public key.
      </p>
      <p>
        This specification is format- and algorithm-focused. API shapes used by
        a specific reference implementation are non-normative, but failure
        conditions are normative.
      </p>
      <p>
        Entry payloads are intentionally schema-flexible. State at a point in
        time is resolved by applying extension members from root to that point
        in chain order.
      </p>
    </section>

    <section>
      <h2>Conventions</h2>
      <p>
        The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD
        NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this document
        are to be interpreted as described in BCP 14 [[!RFC2119]] [[!RFC8174]]
        when, and only when, they appear in all capitals.
      </p>
      <p>
        JSON is defined by [[!RFC8259]]. JWT and NumericDate are defined by
        [[!RFC7519]]. JWS and base64url handling in this specification follow
        [[!RFC7515]]. JWK and JOSE algorithm identifiers are defined by
        [[!RFC7517]] and [[!RFC7518]].
      </p>
    </section>

    <section>
      <h2>Core Terms</h2>
      <dl>
        <dt>
          <dfn data-lt="JSON Web History|JWH">JSON Web History (JWH)</dfn>
        </dt>
        <dd>
          A linear, issuer-scoped chain of signed entries represented as a [=JWH
          snapshot=] or [=JWH string=].
        </dd>

        <dt><dfn data-lt="JWH entry">JWH Entry</dfn></dt>
        <dd>
          A JSON object payload that contains protocol metadata members and MAY
          contain arbitrary extension members.
        </dd>

        <dt><dfn data-lt="JWH entry token">JWH Entry Token</dfn></dt>
        <dd>A JWS Compact Serialization whose payload is a [=JWH entry=].</dd>

        <dt><dfn data-lt="JWH snapshot">JWH Snapshot</dfn></dt>
        <dd>
          A JSON array of [=JWH entry token=] values ordered from root to head.
        </dd>

        <dt><dfn data-lt="JWH string">JWH String</dfn></dt>
        <dd>The JSON string serialization of a [=JWH snapshot=].</dd>

        <dt>
          <dfn data-lt="reserved entry members">Reserved Entry Members</dfn>
        </dt>
        <dd>
          The member names <code>jti</code>, <code>iss</code>, <code>nbf</code>,
          <code>aft</code>, <code>pk</code>, and <code>rot</code>. They are
          protocol metadata and are excluded from [=resolved state=]
          accumulation.
        </dd>

        <dt><dfn data-lt="root pointer">Root Pointer</dfn></dt>
        <dd>
          The string literal <code>U+0000</code>, used as <code>aft</code> in
          exactly one root [=JWH entry=].
        </dd>

        <dt>
          <dfn data-lt="root verification key">Root Verification Key</dfn>
        </dt>
        <dd>
          The public JWK carried in root entry member <code>pk</code>. It
          verifies the root token and initializes the [=active verification
          key=].
        </dd>

        <dt>
          <dfn data-lt="active verification key">Active Verification Key</dfn>
        </dt>
        <dd>
          The public key used to verify the next [=JWH entry token=] in
          root-to-head order. If a verified entry contains <code>rot</code>,
          that key becomes active for subsequent entries.
        </dd>

        <dt><dfn data-lt="resolved state">Resolved State</dfn></dt>
        <dd>
          The JSON object produced for a point in history by applying
          non-reserved members from root to that point in chain order, where
          later values override earlier values for the same key.
        </dd>
      </dl>
    </section>

    <section>
      <h2>JWS Profile</h2>
      <p>
        A [=JWH entry token=] MUST be a JWS Compact Serialization as defined by
        [[!RFC7515]].
      </p>
      <p>The JWS Protected Header MUST contain:</p>
      <ul>
        <li><code>typ</code> with the exact value <code>JWT</code>.</li>
        <li>
          <code>alg</code> set to a JOSE algorithm identifier from [[!RFC7518]].
        </li>
      </ul>
      <p>
        The <code>alg</code> value MUST NOT be <code>none</code>. The signing or
        verification key used for processing a token MUST be a JWK compatible
        with the declared algorithm [[!RFC7517]] [[!RFC7518]].
      </p>
    </section>

    <section>
      <h2>Entry Model</h2>
      <table class="simple">
        <caption>
          Core members of a [=JWH entry=]
        </caption>
        <thead>
          <tr>
            <th>Member</th>
            <th>Type</th>
            <th>Requirements</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>jti</code></td>
            <td>string</td>
            <td>
              MUST be non-empty and unique within one [=JSON Web History=]
              [[!RFC7519]].
            </td>
          </tr>
          <tr>
            <td><code>iss</code></td>
            <td>string</td>
            <td>
              MUST be non-empty and equal across all entries in one [=JSON Web
              History=] [[!RFC7519]].
            </td>
          </tr>
          <tr>
            <td><code>nbf</code></td>
            <td>number</td>
            <td>MUST be a NumericDate [[!RFC7519]].</td>
          </tr>
          <tr>
            <td><code>aft</code></td>
            <td>string</td>
            <td>
              MUST be either [=root pointer=] or the <code>jti</code> of exactly
              one earlier entry in the same history.
            </td>
          </tr>
          <tr>
            <td><code>pk</code></td>
            <td>JSON object (JWK)</td>
            <td>
              MUST be present when <code>aft</code> equals [=root pointer=] and
              MUST be a public JWK compatible with the declared
              <code>alg</code> [[!RFC7517]] [[!RFC7518]].
            </td>
          </tr>
          <tr>
            <td><code>rot</code></td>
            <td>JSON object (JWK)</td>
            <td>
              OPTIONAL. When present, MUST be a public JWK and becomes the
              [=active verification key=] for the next entry in chain order.
            </td>
          </tr>
          <tr>
            <td><code>*</code> (extension members)</td>
            <td>JSON value</td>
            <td>
              MAY contain arbitrary JSON members. This specification imposes no
              fixed payload schema across history entries.
            </td>
          </tr>
        </tbody>
      </table>
      <aside class="warning">
        <p>
          Consideration on whether the <code>aft</code> ("after") field values
          need to be content-addressed or not is required.
        </p>
      </aside>
      <p>
        Implementations MUST preserve unknown extension members when parsing,
        validating, inspecting, and merging histories.
      </p>
    </section>

    <section>
      <h2><dfn data-lt="history validity">History Validity</dfn></h2>
      <p>
        A candidate [=JSON Web History=] is valid only if all of the following
        are true:
      </p>
      <ol>
        <li>It contains at least one [=JWH entry=].</li>
        <li>
          Exactly one entry has <code>aft</code> equal to [=root pointer=].
        </li>
        <li>
          Every non-root entry's <code>aft</code> references an existing
          <code>jti</code> in the same history.
        </li>
        <li>No two entries share the same <code>jti</code>.</li>
        <li>
          No parent entry has more than one child entry (that is, no forks are
          permitted).
        </li>
        <li>
          The chain formed by following <code>aft</code> links from root is
          acyclic and includes every entry exactly once.
        </li>
        <li>All entries have the same <code>iss</code> value.</li>
        <li>
          Root entry contains <code>pk</code> and it is a valid public JWK.
        </li>
        <li>
          In root-to-head chain order, every token verifies with the current
          [=active verification key=], initialized from root <code>pk</code> and
          updated only by verified <code>rot</code> members.
        </li>
      </ol>
    </section>

    <section>
      <h2>Abstract Operations</h2>
      <p>
        This specification defines the following abstract operations: [=create a
        JWH entry=], [=tokenize a JWH entry=], [=parse a JWH entry token=],
        [=verify a JWH entry token=], [=validate a JWH snapshot=], [=start a
        JWH=], [=extend a JWH=], [=inspect a JWH=], and [=merge JWH snapshots=].
      </p>

      <section>
        <h3><dfn data-lt="error code">Error Code</dfn></h3>
        <p>
          A machine-readable identifier for a specific failure condition.
          Conforming implementations MUST expose an [=error code=] for every
          operation failure defined in this specification.
        </p>
        <table class="simple">
          <caption>
            Minimum required [=error code=] conditions
          </caption>
          <thead>
            <tr>
              <th>Code</th>
              <th>Failure condition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>TOKEN_INVALID_COMPACT_JWS</code></td>
              <td>
                A [=JWH entry token=] is not a compact JWS with exactly three
                dot-separated parts.
              </td>
            </tr>
            <tr>
              <td><code>TOKEN_INVALID_PROTECTED_HEADER</code></td>
              <td>
                A protected header is missing required members or violates this
                specification's JWS profile.
              </td>
            </tr>
            <tr>
              <td><code>TOKEN_ALG_NONE_FORBIDDEN</code></td>
              <td>A token declares <code>alg</code> as <code>none</code>.</td>
            </tr>
            <tr>
              <td><code>TOKEN_SIGNATURE_VERIFICATION_FAILED</code></td>
              <td>Signature verification fails for a token.</td>
            </tr>
            <tr>
              <td><code>HISTORY_EMPTY_SNAPSHOT</code></td>
              <td>A [=JWH snapshot=] contains no entries.</td>
            </tr>
            <tr>
              <td><code>HISTORY_ISSUER_MISMATCH</code></td>
              <td>
                Entries in one history do not share the same <code>iss</code>.
              </td>
            </tr>
            <tr>
              <td><code>HISTORY_ROOT_KEY_MISSING</code></td>
              <td>Root entry is missing required <code>pk</code>.</td>
            </tr>
            <tr>
              <td><code>HISTORY_ROOT_KEY_MISMATCH</code></td>
              <td>
                A supplied expected root key does not match root
                <code>pk</code>.
              </td>
            </tr>
            <tr>
              <td><code>HISTORY_ROOT_KEY_INVALID</code></td>
              <td>
                Root <code>pk</code> is not a valid public JWK compatible with
                the chain's verification process.
              </td>
            </tr>
            <tr>
              <td><code>HISTORY_ROTATION_KEY_INVALID</code></td>
              <td>
                A <code>rot</code> member is present but not a valid public JWK.
              </td>
            </tr>
            <tr>
              <td><code>ENTRY_INVALID_CLAIMS_OBJECT</code></td>
              <td>
                Entry creation input <var>claims</var> is not a JSON object.
              </td>
            </tr>
            <tr>
              <td><code>ENTRY_RESERVED_MEMBER_OVERRIDE</code></td>
              <td>
                Entry creation input attempts to set a [=reserved entry
                members=] name through extension members.
              </td>
            </tr>
            <tr>
              <td><code>HISTORY_FORK_DETECTED</code></td>
              <td>More than one child references the same parent entry.</td>
            </tr>
            <tr>
              <td><code>HISTORY_CHAIN_DISCONNECTED</code></td>
              <td>
                The chain is not a single connected root-to-head sequence.
              </td>
            </tr>
            <tr>
              <td><code>HISTORY_MERGE_CONFLICTING_JTI</code></td>
              <td>
                Two snapshots contain the same <code>jti</code> with different
                payloads.
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section>
        <h3><dfn data-lt="create a JWH entry">Create a JWH Entry</dfn></h3>
        <p>
          This operation takes <var>iss</var>, <var>aft</var>, and extension
          members object <var>claims</var> and returns a [=JWH entry=].
        </p>
        <ol class="algorithm">
          <li>
            If <var>claims</var> is not a JSON object, fail with
            <code>ENTRY_INVALID_CLAIMS_OBJECT</code>.
          </li>
          <li>Create a new JSON object <var>entry</var>.</li>
          <li>Set <code>entry.jti</code> to a new non-empty unique string.</li>
          <li>Set <code>entry.iss</code> to <var>iss</var>.</li>
          <li>Set <code>entry.nbf</code> to the current NumericDate.</li>
          <li>Set <code>entry.aft</code> to <var>aft</var>.</li>
          <li>
            For each own member <var>name</var> of <var>claims</var>:
            <ol>
              <li>
                If <var>name</var> is one of [=reserved entry members=], fail
                with <code>ENTRY_RESERVED_MEMBER_OVERRIDE</code>.
              </li>
              <li>Set <code>entry[name]</code> to <var>claims[name]</var>.</li>
            </ol>
          </li>
          <li>Return <var>entry</var>.</li>
        </ol>
      </section>

      <section>
        <h3><dfn data-lt="tokenize a JWH entry">Tokenize a JWH Entry</dfn></h3>
        <p>
          This operation takes a [=JWH entry=] and signing key and returns a
          [=JWH entry token=].
        </p>
        <ol class="algorithm">
          <li>
            Construct a protected header containing <code>typ</code> set to
            <code>JWT</code> and <code>alg</code> set to the key algorithm.
          </li>
          <li>
            Serialize header and payload as UTF-8 JSON and base64url encode each
            value [[!RFC7515]].
          </li>
          <li>
            Sign the JWS Signing Input and produce a JWS Compact Serialization
            [[!RFC7515]].
          </li>
          <li>Return the resulting compact JWS string.</li>
        </ol>
      </section>

      <section>
        <h3>
          <dfn data-lt="parse a JWH entry token">Parse a JWH Entry Token</dfn>
        </h3>
        <p>
          This operation takes a [=JWH entry token=] and returns decoded header,
          payload, signature bytes, and signing input without validating the
          signature.
        </p>
        <ol class="algorithm">
          <li>Split token by <code>.</code> into three parts.</li>
          <li>If there are not exactly three parts, fail.</li>
          <li>Decode and parse protected header JSON.</li>
          <li>Require <code>typ</code> to equal <code>JWT</code>.</li>
          <li>Require <code>alg</code> to be a non-empty string.</li>
          <li>Decode and parse payload JSON as a [=JWH entry=].</li>
          <li>Decode signature bytes.</li>
          <li>Return parsed components.</li>
        </ol>
      </section>

      <section>
        <h3>
          <dfn data-lt="verify a JWH entry token">Verify a JWH Entry Token</dfn>
        </h3>
        <p>
          This operation takes a [=JWH entry token=] and verification key and
          returns the verified [=JWH entry=].
        </p>
        <ol class="algorithm">
          <li>Run [=parse a JWH entry token=].</li>
          <li>If header <code>alg</code> is <code>none</code>, fail.</li>
          <li>
            If the verification key declares an algorithm and it differs from
            header <code>alg</code>, fail.
          </li>
          <li>Verify JWS signature using [[!RFC7515]].</li>
          <li>If signature verification fails, fail.</li>
          <li>Return the parsed payload entry.</li>
        </ol>
      </section>

      <section>
        <h3>
          <dfn data-lt="validate a JWH snapshot">Validate a JWH Snapshot</dfn>
        </h3>
        <p>
          This operation takes a [=JWH snapshot=] (or [=JWH string=]) and
          optionally an expected [=root verification key=] and returns
          normalized history state.
        </p>
        <ol class="algorithm">
          <li>
            If input is a [=JWH string=], run [=parse a JWH string=] to obtain a
            [=JWH snapshot=].
          </li>
          <li>
            If the snapshot is empty, fail with
            <code>HISTORY_EMPTY_SNAPSHOT</code>.
          </li>
          <li>Initialize an empty map keyed by <code>jti</code>.</li>
          <li>Initialize issuer state as unset.</li>
          <li>
            For each token in snapshot order:
            <ol>
              <li>Run [=parse a JWH entry token=].</li>
              <li>
                If issuer state is unset, set issuer state to
                <code>entry.iss</code>; otherwise require equality, or fail with
                <code>HISTORY_ISSUER_MISMATCH</code>.
              </li>
              <li>
                If <code>jti</code> is already present:
                <ol>
                  <li>
                    If payload is equal, fail with
                    <code>HISTORY_DUPLICATE_JTI</code>.
                  </li>
                  <li>
                    Otherwise fail with <code>HISTORY_CONFLICTING_JTI</code>.
                  </li>
                </ol>
              </li>
              <li>Store the entry and token by <code>jti</code>.</li>
            </ol>
          </li>
          <li>
            Apply [=history validity=] requirements that do not depend on
            signature verification.
          </li>
          <li>Compute root-to-head chain order from <code>aft</code> links.</li>
          <li>
            Ensure original token order is root-to-head chain order; otherwise
            fail with <code>HISTORY_UNORDERED_SNAPSHOT</code>.
          </li>
          <li>Let <var>root</var> be the first entry in chain order.</li>
          <li>
            If <var>root</var> is missing <code>pk</code>, fail with
            <code>HISTORY_ROOT_KEY_MISSING</code>.
          </li>
          <li>
            If <code>root.pk</code> is not a valid public JWK, fail with
            <code>HISTORY_ROOT_KEY_INVALID</code>.
          </li>
          <li>
            If an expected root verification key is provided and it does not
            equal <code>root.pk</code>, fail with
            <code>HISTORY_ROOT_KEY_MISMATCH</code>.
          </li>
          <li>
            Initialize [=active verification key=] from
            <code>root.pk</code>.
          </li>
          <li>
            For each entry in chain order:
            <ol>
              <li>
                Run [=verify a JWH entry token=] using that entry's token and
                the current [=active verification key=].
              </li>
              <li>
                If entry has <code>rot</code>:
                <ol>
                  <li>
                    If <code>entry.rot</code> is not a valid public JWK, fail
                    with <code>HISTORY_ROTATION_KEY_INVALID</code>.
                  </li>
                  <li>
                    Set [=active verification key=] to
                    <code>entry.rot</code>.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return normalized validated state.</li>
        </ol>
      </section>

      <section>
        <h3><dfn data-lt="parse a JWH string">Parse a JWH String</dfn></h3>
        <p>
          This operation takes a [=JWH string=] and returns a [=JWH snapshot=].
        </p>
        <ol class="algorithm">
          <li>Parse the input as JSON.</li>
          <li>
            If parsing fails or the value is not a JSON array, fail with
            <code>STRING_INVALID_JSON_ARRAY</code>.
          </li>
          <li>
            Require each array item to be a non-empty string, or fail with
            <code>STRING_INVALID_SNAPSHOT_TOKEN</code>.
          </li>
          <li>Return the array as a [=JWH snapshot=].</li>
        </ol>
      </section>

      <section>
        <h3><dfn data-lt="start a JWH">Start a JWH</dfn></h3>
        <p>
          This operation takes <var>iss</var>, extension members object
          <var>claims</var>, a root signing key, and a root public key, and
          returns a [=JWH string=].
        </p>
        <ol class="algorithm">
          <li>
            Let <var>entry</var> be the result of [=create a JWH entry=] with
            <code>aft</code> set to [=root pointer=] and <var>claims</var>.
          </li>
          <li>Set <code>entry.pk</code> to the supplied root public key.</li>
          <li>
            Let <var>token</var> be the result of [=tokenize a JWH entry=] using
            <var>entry</var> and the root signing key.
          </li>
          <li>
            Let <var>snapshot</var> be an array containing <var>token</var>.
          </li>
          <li>Run [=validate a JWH snapshot=] on <var>snapshot</var>.</li>
          <li>Return JSON serialization of <var>snapshot</var>.</li>
        </ol>
      </section>

      <section>
        <h3><dfn data-lt="extend a JWH">Extend a JWH</dfn></h3>
        <p>
          This operation appends a new entry to a valid history. It takes an
          existing history, extension members object <var>claims</var>, a
          signing key, and optional rotation key <var>nextKey</var>, and returns
          a [=JWH string=].
        </p>
        <ol class="algorithm">
          <li>Run [=validate a JWH snapshot=] on the input history.</li>
          <li>
            Let <var>head</var> be the last entry in validated chain order.
          </li>
          <li>
            Let <var>entry</var> be [=create a JWH entry=] with
            <code>iss = head.iss</code>, <code>aft = head.jti</code>, and
            <var>claims</var>.
          </li>
          <li>
            If <var>nextKey</var> is present:
            <ol>
              <li>
                If <var>nextKey</var> is not a valid public JWK, fail with
                <code>HISTORY_ROTATION_KEY_INVALID</code>.
              </li>
              <li>Set <code>entry.rot</code> to <var>nextKey</var>.</li>
            </ol>
          </li>
          <li>
            Let <var>token</var> be [=tokenize a JWH entry=] for
            <var>entry</var>.
          </li>
          <li>Append <var>token</var> to the snapshot.</li>
          <li>Run [=validate a JWH snapshot=] on the updated snapshot.</li>
          <li>Return JSON serialization of the updated snapshot.</li>
        </ol>
      </section>

      <section>
        <h3><dfn data-lt="inspect a JWH">Inspect a JWH</dfn></h3>
        <p>
          This operation returns the [=resolved state=] at time <var>t</var>.
        </p>
        <ol class="algorithm">
          <li>Run [=validate a JWH snapshot=].</li>
          <li>
            Select entries in validated chain order where
            <code>entry.nbf &lt;= t</code>.
          </li>
          <li>If no entry remains, fail.</li>
          <li>Initialize an empty JSON object <var>state</var>.</li>
          <li>
            For each selected entry in chain order:
            <ol>
              <li>
                For each own member name-value pair in the entry:
                <ol>
                  <li>
                    If name is one of [=reserved entry members=], continue.
                  </li>
                  <li>Set <code>state[name]</code> to <code>value</code>.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return <var>state</var>.</li>
        </ol>
      </section>

      <section>
        <h3><dfn data-lt="merge JWH snapshots">Merge JWH Snapshots</dfn></h3>
        <p>
          This operation takes one or more [=JWH snapshot=] values and returns a
          single merged [=JWH snapshot=].
        </p>
        <p>
          A merge MUST be accepted whenever the deduplicated token set forms one
          directed linear root-to-head graph and validates from root
          <code>pk</code> through any verified <code>rot</code> transitions.
        </p>
        <ol class="algorithm">
          <li>
            If no input snapshots are provided, fail with
            <code>HISTORY_MERGE_EMPTY_INPUT</code>.
          </li>
          <li>Initialize an empty map keyed by <code>jti</code>.</li>
          <li>
            For each input snapshot and each token in that snapshot:
            <ol>
              <li>Run [=parse a JWH entry token=].</li>
              <li>
                If an entry with the same <code>jti</code> already exists:
                <ol>
                  <li>
                    If payload differs, fail with
                    <code>HISTORY_MERGE_CONFLICTING_JTI</code>.
                  </li>
                  <li>If payload is equal, ignore the duplicate token.</li>
                </ol>
              </li>
              <li>Otherwise add the entry and token to merge state.</li>
            </ol>
          </li>
          <li>
            Apply [=history validity=] requirements that do not depend on
            signature verification.
          </li>
          <li>
            Order merged entries from root to head using <code>aft</code> links.
          </li>
          <li>
            Let <var>mergedSnapshot</var> be tokens in that order. If a token is
            missing for any entry, fail with
            <code>HISTORY_MERGE_MISSING_TOKEN</code>.
          </li>
          <li>Run [=validate a JWH snapshot=] on <var>mergedSnapshot</var>.</li>
          <li>Return <var>mergedSnapshot</var>.</li>
        </ol>
      </section>
    </section>

    <section class="informative">
      <h2>Reference Implementation Mapping</h2>
      <p>
        A reference TypeScript implementation can expose these operations as
        top-level functions and optional convenience classes. Class names and
        method names are not normative requirements of this specification.
      </p>
    </section>

    <section>
      <h2>Security Considerations</h2>
      <p>
        Implementations MUST follow JWT best current practices from
        [[!RFC8725]]. In particular, implementations MUST enforce algorithm
        allowlists and MUST reject <code>alg=none</code>.
      </p>
      <p>
        Consumers MUST verify every token signature before relying on entry
        contents. Treating unverified payload data as trusted history state can
        enable forgery.
      </p>
      <p>
        Consumers MUST derive verification keys from root <code>pk</code> and
        only from verified <code>rot</code> transitions.
      </p>
      <p>
        Implementations MUST treat malformed or invalid histories as hard
        failures and MUST NOT auto-repair by dropping conflicting entries.
      </p>
    </section>

    <section>
      <h2>IANA Considerations</h2>
      <p>This document has no IANA actions.</p>
    </section>

    <section id="conformance">
      <p>
        This specification defines conformance requirements for producers and
        consumers of [=JSON Web History=] artifacts. Requirements are expressed
        in this document using the terminology defined in [[#conventions]].
      </p>
    </section>
  </body>
</html>
